#!/usr/bin/env python
# -*- coding: utf-8 -*-
"""
Generalized instrument that services commands generated by clients over
variuos protocols (MQTT, OPC UA).
"""
import queue
import threading
import logging
from lib import helper_functions
from services.opc.subscriber import Subscriber
from time import sleep
from pdb import set_trace

__author__ = "Brent Maranzano"
__license__ = "MIT"


logger = logging.getLogger("instrument")


class Instrument(object):
    """Abastract instrument interface that services command requests generated
    by clients connected by various protocols (e.g. MQTT, HTTP, OPC UA).
    Service parameters and command mappings are defined in an auxillary YAML
    file.  Inhereting classes provide the instrument specific available
    commands.
    """

    def __init__(self, config_file):
        """Sets an object attribute with defining the service parameters

        Arguments
        config_file (str): Filename containing the configuration parameters for
            the instrument and services.
        opc_handler (Subscription): Object to handle callbacks from OPC node
            changes.
        """
        self._params = self._get_parameters(config_file)
        self._queue = queue.Queue()
        self._user = None
        self._password = None
        self._commands = None

    def _get_parameters(self, config_file):
        """Read and parse the yaml file containing the
        configuration parameters to start the services.

        Arguments
        config_file (str): Filename containing parameters formatted
                            as yaml.

        returns (dict): Parameters.
        """
        params = helper_functions.yaml_to_dict(config_file)
        return params

    def _connect_instrument(self):
        """Create connection to instrument. Method to be over-ridden.
        """
        pass

    def _update_data(self):
        """Periodically get the current instrument data and store
        in class attribute to expedite responses to service requests.
        Method is to be over-ridden.
        """
        pass

    def _process_queue(self):
        """Pop a request off of the queue and process the request.
        """
        logger.info("process queue thread starting")
        while True:
            request = self._queue.get()
            self._process_request(request)

    def _process_request(self, request):
        """Proces the reqest.

        Arguments
        request (dict): Details of service request
           command (str): Name of command to execute
           parameters (command dependent): Parameters for command.
           callback (fun): function to call back with command results.
        """
        # possible blocking call
        response = getattr(self, request["command"])(request["parameters"])
        request["callback"](response)

    def _queue_request(self, **request):
        """Queue requests.

        Arguments
        request (dict): Details of service request
           command (str): Name of command to execute
           parameters (command dependent): Parameters for command.
           callback (fun): function to call back with command results.
        """
        self._queue.put(request)

    def _start_services(self):
        """Start the listening services if the service is defined
        in the configuration file.
        """
        logger.info("starting services")
        threading.Thread(target=self._process_queue, daemon=True).start()
        threading.Thread(target=self._update_data, daemon=True).start()
        if "opc-client" in self._params:
            self._opc_sub = Subscriber(
                callback=self._queue_request,
                **self._params["opc-client"]
            )
            self._opc_sub.run()
        if "mqtt" in self._params:
            self._mqtt_client = MqttClient.run(
                callback=self._queue_request,
                **self._params["mqtt"]
            )
