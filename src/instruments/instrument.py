#!/usr/bin/env python
# -*- coding: utf-8 -*-
"""
Generalized instrument that services commands generated by clients over
variuos protocols (MQTT, OPC UA).
"""
import queue
import threading
import logging
from lib import helper_functions
from services.opc.client import Client as OpcClient
from services.opc.handler import Handler as OpcHandler
from time import sleep
from pdb import set_trace

__author__ = "Brent Maranzano"
__license__ = "MIT"


logger = logging.getLogger("instrument")


class Instrument(object):
    """Abastract instrument interface that services command requests generated
    by clients connected by various protocols (e.g. MQTT, HTTP, OPC UA).
    Service parameters and command mappings are defined in an auxillary YAML
    file.  Inhereting classes provide the instrument specific available
    commands.
    """

    def __init__(self, config_file):
        """Sets an object attribute with defining the service parameters

        Arguments
        config_file (str): Filename containing the configuration parameters for
            the instrument and services.
        opc_handler (Subscription): Object to handle callbacks from OPC node
            changes.
        """
        self._params = self._get_parameters(config_file)
        self._queue = queue.Queue()
        self._user = None
        self._password = None
        self._commands = None

    def _get_parameters(self, config_file):
        """Read and parse the yaml file containing the
        configuration parameters to start the services.

        Arguments
        config_file (str): Filename containing parameters formatted
                            as yaml.

        returns (dict): Parameters.
        """
        params = helper_functions.yaml_to_dict(config_file)
        return params

    def _connect_instrument(self):
        """Create connection to instrument. Method to be over-ridden.
        """
        pass

    def _update_data(self):
        """Periodically get the current instrument data and store
        in class attribute to expedite responses to service requests.
        Method is to be over-ridden.
        """
        pass

    def _process_queue(self):
        """Pop a request off of the queue and process the request.
        """
        logger.info("process queue thread starting")
        while True:
            request = self._queue.get()
            # blocking call
            self._process_request(**request)
        return

    def _process_request(self, service=None, payload=None):
        """Process the request. Add additional functionality
        here.

        Arguments
        service (str): Name of service that produced request.
        payload (varies): Request information provided by service.
        """
        logger.debug("process request")
        if not self._validate_request(payload):
            return
        if service == "opc":
            response = self._process_opc_request(
                node=str(payload[0].get_browse_name()),
                value=payload[1]
            )
            self._opc_client.respond(**response)

    def _validate_request(self, request):
        """Validate that the request has the correct user and password,
        if it is set.

        Arguments
        request (dict): Request object

        returns (bool): True if valid, False if invalid
        """
        if self._user is None and self._password is None:
            return True
        elif (request["user"] == self._user
              and request["password"] == self._password):
            return True
        else:
            logger.info("Received an invalid request.")
            return False

    def _queue_request(self, request):
        """Queue requests from the serivces.

        Arguments
        request (dict): service request data
            {"service": service_originator, "payload": service_data}
        """
        self._queue.put(request)

    def _start_services(self):
        """Start the listening services if the service is defined
        in the configuration file.
        """
        logger.info("starting services")
        threading.Thread(target=self._process_queue, daemon=True).start()
        threading.Thread(target=self._update_data, daemon=True).start()
        if "opc" in self._params:
            self._opc_client = OpcClient.run(
                sub_handler=OpcHandler(self._queue_request),
                **self._params["opc"]
            )
